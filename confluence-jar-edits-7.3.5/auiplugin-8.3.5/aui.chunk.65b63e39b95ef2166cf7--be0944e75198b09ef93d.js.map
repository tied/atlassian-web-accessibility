{"version":3,"sources":["webpack:///../src/js/aui/internal/alignment.js"],"names":["__webpack_require__","ATTR_ALIGNMENT","DEFAULT_ATTACHMENT","ATTR_CONTAINER","CLASS_PREFIX_SIDE","CLASS_PREFIX_SNAP","GPU_ACCELERATION_FLAG","ALIGNMENT_MAP","top left","top center","top right","right top","right middle","right bottom","bottom right","bottom center","bottom left","left bottom","left middle","left top","getAttribute","element","name","getAlignmentAttribute","calculateBestAlignmentSnap","target","container","window","document","querySelector","getContainer","snap","documentElement","nodeType","Node","ELEMENT_NODE","containerBounds","getBoundingClientRect","left","right","getFlipBehavior","auto","top","bottom","Alignment","options","arguments","length","undefined","alignment","_getAlignmentAttribut","split","_getAlignmentAttribut2","_slicedToArray","side","getAlignment","placement","attr","getPlacement","flipBehavior","modifiers","flip","enabled","hasOwnProperty","behavior","boundariesElement","flipContainer","preventOverflow","padding","escapeWithReference","overflowContainer","hide","computeStyle","gpuAcceleration","body","classList","contains","popperConfig","eventsEnabled","positionFixed","forEach","callbackName","callback","this","popper","Popper","sideClass","snapClass","add","addAlignmentClasses","prototype","destroy","changeTarget","newTarget","referenceEl","jquery","shouldRebind","state","reference","disable","enable","scheduleUpdate","enableEventListeners","disableEventListeners"],"mappings":"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","file":"aui.chunk.65b63e39b95ef2166cf7--be0944e75198b09ef93d.js","sourcesContent":["import Popper from 'popper.js';\n\nconst ATTR_ALIGNMENT = 'alignment';\nconst DEFAULT_ATTACHMENT = 'right middle';\nconst ATTR_CONTAINER = 'alignment-container';\nconst CLASS_PREFIX_SIDE = 'aui-alignment-side-';\nconst CLASS_PREFIX_SNAP = 'aui-alignment-snap-';\nexport const GPU_ACCELERATION_FLAG = 'aui-alignment-use-gpu';\n\n/**\n * The \"side\" and \"snap\" that an element should use when aligning, where:\n * - \"side\" is the edge of the **target** that the aligned element should touch, and\n * - \"snap\" is the effective position that both the target and aligned element should share.\n * @enum {String}\n * @name AlignmentType\n */\nconst ALIGNMENT_MAP = {\n    'top left': 'top-start',\n    'top center': 'top',\n    'top right': 'top-end',\n    'right top': 'right-start',\n    'right middle': 'right',\n    'right bottom': 'right-end',\n    'bottom right': 'bottom-end',\n    'bottom center': 'bottom',\n    'bottom left': 'bottom-start',\n    'left bottom': 'left-end',\n    'left middle': 'left',\n    'left top': 'left-start',\n};\n\nfunction getAttribute(element, name) {\n    return element.getAttribute(name) || element.getAttribute('data-aui-' + name);\n}\n\nfunction getAlignmentAttribute(element) {\n    return getAttribute(element, ATTR_ALIGNMENT) || DEFAULT_ATTACHMENT;\n}\n\nfunction getPlacement(element) {\n    const attr = getAlignmentAttribute(element);\n    return ALIGNMENT_MAP[attr] || 'right';\n}\n\nfunction getAlignment(element) {\n    let [side, snap] = (getAlignmentAttribute(element)).split(' ');\n    return {\n        side,\n        snap\n    };\n}\n\nfunction addAlignmentClasses(element, side, snap) {\n    const sideClass = CLASS_PREFIX_SIDE + side;\n    const snapClass = CLASS_PREFIX_SNAP + snap;\n\n    if (!element.classList.contains(sideClass)) {\n        element.classList.add(sideClass);\n    }\n\n    if (!element.classList.contains(snapClass)) {\n        element.classList.add(snapClass);\n    }\n}\n\nfunction getContainer (element) {\n    let container = getAttribute(element, ATTR_CONTAINER) || window;\n\n    if (typeof container === 'string') {\n        container = document.querySelector(container);\n    }\n\n    return container;\n}\n\nfunction calculateBestAlignmentSnap (target) {\n    let container = getContainer(target);\n    let snap = 'left';\n\n    if (!container || container === window || container === document) {\n        container = document.documentElement;\n    }\n\n    if (container && container.nodeType && container.nodeType === Node.ELEMENT_NODE) {\n        let containerBounds = container.getBoundingClientRect();\n        let targetBounds = target.getBoundingClientRect();\n\n        if (targetBounds.left > containerBounds.right / 2) {\n            snap = 'right';\n        }\n    }\n\n    return snap;\n}\n\n/*\n    this determines flip order e.g.\n    for top it will try to position itself at the top,\n    if there is no space try to flip to bottom and if there is no space it will stay at the top\n*/\nconst getFlipBehavior = {\n    auto: [],\n    top: ['top', 'bottom', 'top'],\n    right: ['right', 'left', 'right'],\n    bottom: ['bottom', 'top', 'bottom'],\n    left: ['left', 'right', 'left'],\n};\n\n/**\n * Visually positions an element adjacent to another one in the DOM.\n * Can also be told to keep the element aligned\n * when the user resizes the browser or scrolls around the page.\n * @constructor\n * @constructs Alignment\n * @param {HTMLElement} element - the element that will be repositioned. Should have an \"alignment\" attribute\n *   with a valid {@link AlignmentType} value.\n * @param {HTMLElement} target - the point in the DOM to visually position the {@param element} adjacent to.\n * @param {Object} [options]\n * @param {boolean} [options.preventOverflow=true] - if true, will cause element to not overflow viewable area\n * @param {boolean} [options.flip=true] - if true, will cause the element to attempt to reposition itself within\n *   a viewable area as its {@param target} disappears from view.\n * @param {HTMLElement|'viewport'|'window'|'scrollContainer'} [options.flipContainer='viewport'] - the container\n *   in which the element should attempt to stay within the viewable area of.\n *   Used in conjunction with {@param options.flip}.\n * @param {HTMLElement|'viewport'|'window'|'scrollContainer'} [options.overflowContainer='window'] - the container\n *   in which the element should attempt to stay within the viewable area of.\n *   Used in conjunction with {@param options.preventOverflow}.\n * @param {Function} [options.onCreate] - called when the element is first positioned upon creation of the Alignment.\n * @param {Function} [options.onUpdate] - called whenever the element is positioned, except upon creation.\n */\nfunction Alignment(element, target, options = {}) {\n    const alignment = getAlignment(element);\n\n    let placement;\n\n    if (!alignment.snap || alignment.snap === 'auto') {\n        alignment.snap = calculateBestAlignmentSnap(target);\n        if (alignment.side === 'submenu') {\n            placement = ALIGNMENT_MAP[`${alignment.snap === 'right' ? 'left' : 'right'} top`];\n        } else {\n            placement = ALIGNMENT_MAP[`${alignment.side} ${alignment.snap}`];\n        }\n    } else {\n        placement = getPlacement(element);\n    }\n\n    const flipBehavior = getFlipBehavior[placement.split('-')[0]];\n\n    const modifiers = {\n        flip: {\n            enabled: options.hasOwnProperty('flip') ? options.flip : true,\n            behavior: flipBehavior,\n            boundariesElement: options.hasOwnProperty('flipContainer') ? options.flipContainer : 'viewport',\n        },\n        preventOverflow: {\n            enabled: options.hasOwnProperty('preventOverflow') ? options.preventOverflow : true,\n            padding: 0,\n            escapeWithReference: false,\n            boundariesElement: options.hasOwnProperty('overflowContainer') ? options.overflowContainer : 'window',\n        },\n        hide: {\n            enabled: false\n        },\n        computeStyle: {\n            gpuAcceleration: document.body.classList.contains(GPU_ACCELERATION_FLAG)\n        }\n    };\n    const popperConfig = {\n        eventsEnabled: false,\n        placement,\n        positionFixed: options.hasOwnProperty('positionFixed') ? options.positionFixed : true,\n        modifiers\n    };\n\n    ['onCreate', 'onUpdate'].forEach(function(callbackName) {\n        var callback = options[callbackName];\n        if (typeof callback === 'function') {\n            popperConfig[callbackName] = callback;\n        }\n    });\n\n    this.popper = new Popper(target, element, popperConfig);\n\n    addAlignmentClasses(element, alignment.side, alignment.snap);\n}\n\nAlignment.prototype = {\n\n    destroy() {\n        this.popper.destroy();\n        return this;\n    },\n\n    /**\n     * Changes what the aligned element is trying to align itself with.\n     * Will call {@link #scheduleUpdate} as needed to ensure the element will be aligned\n     * with whatever the new target is.\n     * @param {HTMLElement} newTarget - the new target DOM element to align the element with.\n     * @returns {Alignment}\n     */\n    changeTarget(newTarget) {\n        const referenceEl = newTarget.jquery ? newTarget[0] : newTarget;\n        const shouldRebind = this.popper.state.eventsEnabled;\n        if (referenceEl && referenceEl !== this.popper.reference) {\n            shouldRebind && this.disable();\n            this.popper.reference = referenceEl;\n            shouldRebind && this.enable();\n            this.scheduleUpdate();\n        }\n        return this;\n    },\n\n    /**\n     * The position of the element will be updated on the next execution stack.\n     * Triggering a render this way will always be asynchronous.\n     * @returns {Alignment}\n     */\n    scheduleUpdate() {\n        this.popper.scheduleUpdate();\n        return this;\n    },\n\n    /**\n     * Causes the position of the element to auto-update\n     * when the browser window resizes or scroll parent is scrolled.\n     * @returns {Alignment}\n     */\n    enable() {\n        this.popper.enableEventListeners();\n        return this;\n    },\n\n    /**\n     * Prevents the position of the element from auto-updating\n     * when the browser window resizes or scroll parent is scrolled.\n     * @returns {Alignment}\n     */\n    disable() {\n        this.popper.disableEventListeners();\n        return this;\n    },\n};\n\nexport default Alignment;\n"],"sourceRoot":""}