{"version":3,"sources":["webpack:////buildeng/bamboo-agent-home/xml-data/build-dir/AUI-RELNEXT19-JOB1/aui/node_modules/jquery-ui/ui/position.js"],"names":["__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","__webpack_require__","undefined","$","cachedScrollbarWidth","max","Math","abs","rhorizontal","rvertical","roffset","rposition","rpercent","_position","fn","position","getOffsets","offsets","width","height","parseFloat","test","parseCss","element","property","parseInt","css","scrollbarWidth","w1","w2","div","innerDiv","children","append","offsetWidth","clientWidth","remove","getScrollInfo","within","overflowX","isWindow","isDocument","overflowY","hasOverflowX","scrollWidth","scrollHeight","getWithinInfo","withinElement","window","nodeType","offset","left","top","scrollLeft","scrollTop","outerWidth","outerHeight","options","of","apply","this","arguments","extend","atOffset","targetWidth","targetHeight","targetOffset","basePosition","dimensions","target","scrollInfo","collision","split","elem","raw","preventDefault","pageY","pageX","getDimensions","at","each","horizontalOffset","verticalOffset","pos","length","concat","exec","collisionPosition","using","elemWidth","elemHeight","marginLeft","marginTop","collisionWidth","collisionHeight","myOffset","my","i","dir","ui","props","right","bottom","feedback","horizontal","vertical","important","call","fit","data","newOverRight","withinOffset","collisionPosLeft","overLeft","overRight","newOverBottom","collisionPosTop","overTop","overBottom","flip","newOverLeft","offsetLeft","newOverTop","offsetTop","flipfit","exports","module"],"mappings":"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","file":"aui.chunk.a7fc0d5b8767e9b40315--bdd2730e8619a65df894.js","sourcesContent":["/*!\n * jQuery UI Position 1.12.1\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n( function( factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ \"jquery\", \"./version\" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}( function( $ ) {\n( function() {\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[ 0 ];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( $.isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div \" +\n\t\t\t\t\"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>\" +\n\t\t\t\t\"<div style='height:100px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[ 0 ];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[ 0 ].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn ( cachedScrollbarWidth = w1 - w2 );\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisWindow = $.isWindow( withinElement[ 0 ] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n\t\t\thasOffset = !isWindow && !isDocument;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: withinElement.outerWidth(),\n\t\t\theight: withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// Make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\t\ttarget = $( options.of ),\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[ 0 ].preventDefault ) {\n\n\t\t// Force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\n\t// Clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// Force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1 ) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// Calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// Reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t} );\n\n\t// Normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each( function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n\t\t\t\tscrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n\t\t\t\tscrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tif ( options.using ) {\n\n\t\t\t// Adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t} );\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// Element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\n\t\t\t\t// Element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\n\t\t\t\t// Element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\n\t\t\t\t// Element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\n\t\t\t// Too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// Element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\n\t\t\t\t// Element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\n\t\t\t\t// Element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\n\t\t\t\t// Element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\n\t\t\t// Too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n\t\t\t\t\touterWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n\t\t\t\t\tatOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n\t\t\t\t\touterHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n\t\t\t\t\toffset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n} )();\n\nreturn $.ui.position;\n\n} ) );\n"],"sourceRoot":""}