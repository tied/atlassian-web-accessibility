{"version":3,"sources":["webpack:///../src/js/aui/focus-manager.js","webpack:///../src/js/aui/layer.js"],"names":["__webpack_require__","_trigger","visible","element","$","css","_jquery2","default","is","focusable","isTabIndexNotNaN","nodeName","toLowerCase","map","parentNode","mapName","name","imageMap","get","href","isFormElement","test","isAnchor","isAnchorTabbable","disabled","extend","expr","pseudos","aui-focusable","isNaN","attr","aui-tabbable","tabIndex","isTabIndexNaN","RESTORE_FOCUS_DATA_KEY","elementTrapsFocus","$el","FocusManager","this","_focusTrapStack","_handler","defaultFocusSelector","prototype","enter","lastFocussedEl","arguments","length","undefined","document","activeElement","data","setLastFocus","focusSelector","find","first","trigger","push","focusTrapStack","event","keyCode","keyCodes","TAB","offset","shiftKey","focusOrigin","target","$focusTrapElement","$tabbableElements","originIdx","index","newFocusIdx","$controlledElementWithFocus","closest","$controllingElements","$controlledElements","getElementById","getAttribute","has","$subTabbable","subOriginIdx","subMove","triggerEl","getTrigger","eq","preventDefault","bind","on","exit","pop","off","$restoreFocus","getLastFocus","removeData","instance","getFocusManager","global","_globalize2","_blanket","EVENT_PREFIX","GLOBAL_EVENT_PREFIX","LAYER_EVENT_PREFIX","AUI_EVENT_PREFIX","$doc","onTransitionEnd","el","prop","func","once","transition","window","getComputedStyle","transitionProperty","indexOf","isTransitioning","call","addEventListener","handler","e","propertyName","removeEventListener","triggerEvent","deprecatedName","newNativeName","e1","Event","e2","nativeEvent","CustomEvent","bubbles","cancelable","nativeEvent2","dispatchEvent","isDefaultPrevented","defaultPrevented","Layer","selector","addClass","below","LayerManager","item","above","changeSize","width","height","fn","show","isVisible","ariaShow","hide","ariaHide","thisLayer","oneTransitionEnd","style","display","popUntil","remove","isBlanketed","isPersistent","modal","hasAttribute","_hideLayer","triggerBeforeEvents","_showLayer","zIndex","parent","appendTo","body","createLayer","_widget2","topIndexWhere","layerArr","i","layerIndex","$layer","topBlanketedIndex","updateBlanket","stack","oldBlanketIndex","newTopBlanketedIndex","dim","undim","popLayers","stopIndex","forceClosePersistent","a","layer","splice","_stack","hasLayer","$trigger","eventName","Error","popLayersBeside","_nextZIndex","$topEl","parseInt","Math","max","nextZIndex","hasTrigger","parentLayer","getParentLayer","parentIndex","blanketedIndex","hideAll","slice","reverse","forEach","getNextLowerNonPersistentOrBlanketedLayer","$nextEl","getNextHigherNonPeristentAndNonBlanketedLayer","oldTopBlanketedIndex","getTopLayer","popTopIfNonPersistent","$topLayer","popUntilTopBlanketed","$topBlanketedLayer","$next","popUntilTopPersistent","$toPop","toPop","ESCAPE","$target","customEvent","Manager"],"mappings":"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","file":"aui.chunk.445dda14d1385eb5a949--a71ec0694cacf24e917f.js","sourcesContent":["import $ from './jquery';\nimport globalize from './internal/globalize';\nimport keyCodes from './key-code';\nimport {getTrigger} from './trigger';\n\n(function initSelectors () {\n    /*\n    :tabbable and :focusable functions from jQuery UI v 1.10.4\n    renamed to :aui-tabbable and :aui-focusable to not clash with jquery-ui if it's included.\n    */\n\n    function visible (element) {\n        return ($.css(element, 'visibility') === 'visible') && $(element).is(':visible');\n    }\n\n    function focusable (element, isTabIndexNotNaN) {\n        var nodeName = element.nodeName.toLowerCase();\n\n        if (nodeName === 'aui-select') {\n            return true;\n        }\n\n        if (nodeName === 'area') {\n            var map = element.parentNode;\n            var mapName = map.name;\n            var imageMap = $('img[usemap=#' + mapName + ']').get();\n\n            if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\n                return false;\n            }\n            return imageMap && visible(imageMap);\n        }\n        var isFormElement = /input|select|textarea|button|object/.test(nodeName);\n        var isAnchor = nodeName === 'a';\n        var isAnchorTabbable = (element.href || isTabIndexNotNaN);\n\n        return (\n            isFormElement ? !element.disabled :\n                (isAnchor ? isAnchorTabbable : isTabIndexNotNaN)\n        ) && visible(element);\n    }\n\n    function tabbable (element) {\n        var tabIndex = $.attr(element, 'tabindex');\n        var isTabIndexNaN = isNaN(tabIndex);\n        var hasTabIndex = (isTabIndexNaN || tabIndex >= 0);\n\n        return hasTabIndex && focusable(element, !isTabIndexNaN);\n    }\n\n    $.extend($.expr.pseudos, {\n        'aui-focusable': element => focusable(element, !isNaN($.attr(element, 'tabindex'))),\n        'aui-tabbable': tabbable\n    });\n}());\n\nvar RESTORE_FOCUS_DATA_KEY = '_aui-focus-restore';\n\nfunction setLastFocus ($el, lastFocussedEl = document.activeElement) {\n    $el.data(RESTORE_FOCUS_DATA_KEY, lastFocussedEl);\n}\n\nfunction getLastFocus ($el) {\n    return $($el.data(RESTORE_FOCUS_DATA_KEY));\n}\n\nfunction elementTrapsFocus ($el) {\n    return $el.is('.aui-dialog2');\n}\n\nfunction FocusManager() {\n    this._focusTrapStack = [];\n    this._handler;\n}\nFocusManager.defaultFocusSelector = ':aui-tabbable';\nFocusManager.prototype.enter = function ($el) {\n    setLastFocus($el);\n\n    // focus on new selector\n    if ($el.attr('data-aui-focus') !== 'false') {\n        var focusSelector = $el.attr('data-aui-focus-selector') || FocusManager.defaultFocusSelector;\n        var $focusEl = $el.is(focusSelector) ? $el : $el.find(focusSelector);\n        $focusEl.first().trigger('focus');\n    }\n\n    if (elementTrapsFocus($el)) {\n        this._focusTrapStack.push($el);\n        if (!this._handler) {\n            this._handler = focusTrapHandler.bind(undefined, this._focusTrapStack);\n            $(document).on('keydown.aui-focus-manager', this._handler);\n        }\n    }\n};\n\nFocusManager.prototype.exit = function ($el) {\n    if (elementTrapsFocus($el)) {\n        this._focusTrapStack.pop();\n        if (!this._focusTrapStack.length) {\n            $(document).off('.aui-focus-manager', this._handler);\n            delete this._handler;\n        }\n    }\n\n    // AUI-1059: remove focus from the active element when dialog is hidden\n    // AUI-5014 - if focus is already outside focus trap there is no need to restore it\n    var activeElement = document.activeElement;\n    if ($el[0] === activeElement || $el.has(activeElement).length) {\n        $(activeElement).trigger('blur');\n        var $restoreFocus = getLastFocus($el);\n        if ($restoreFocus.length) {\n            $el.removeData(RESTORE_FOCUS_DATA_KEY);\n            $restoreFocus.trigger('focus');\n        }\n    }\n};\n\nfunction focusTrapHandler(focusTrapStack, event) {\n    if (focusTrapStack.length === 0) {\n        return;\n    }\n\n    if (event.keyCode !== keyCodes.TAB) {\n        return;\n    }\n\n    const backwards = event.shiftKey;\n    const offset = backwards ? -1 : 1;\n\n    /**\n     * always the element where focus is about to be blurred\n     * @type {HTMLElement}\n     */\n    const focusOrigin = event.target;\n\n    const $focusTrapElement = focusTrapStack[focusTrapStack.length - 1];\n    const $tabbableElements = $focusTrapElement.find(':aui-tabbable');\n\n    // it's not possible to trap focus inside something with no focussable elements!\n    if (!$tabbableElements.length) {\n        return;\n    }\n\n    const originIdx = $tabbableElements.index(focusOrigin);\n    let newFocusIdx = -1;\n\n    if (originIdx > -1) {\n        // the currently focussed element is inside our trap container.\n        // excellent! we'll work with this.\n        newFocusIdx = originIdx;\n    } else {\n        // the currently focussed element was outside our trap container.\n        // it might be okay to leave it there, though, since AUI has a few layer elements\n        // and the focussed element might be in one of those.\n        // let's see if the focus was in an element that AUI roughly \"controls\".\n        let $controlledElementWithFocus;\n\n        // look for a layer in the \"cheapest\" way possible first -- check if a parent is a layer.\n        $controlledElementWithFocus = $(focusOrigin).closest('.aui-layer');\n\n        if (!$controlledElementWithFocus.length) {\n            // look up the controlled layers in a different way -- by finding all controllers first,\n            // then their layers.\n            const $controllingElements = $focusTrapElement.find('[aria-controls]');\n            const $controlledElements = $controllingElements.map(function () {\n                return document.getElementById(this.getAttribute('aria-controls'));\n            });\n\n            // Find out whether the new focus target is inside a controlled element or not.\n            $controlledElementWithFocus = $controlledElements.has(focusOrigin);\n        }\n\n        if ($controlledElementWithFocus.length) {\n            // Find out whether we need to jump the focus out of the controlled element.\n            const $subTabbable = $controlledElementWithFocus.find(':aui-tabbable');\n            const subOriginIdx = $subTabbable.index(focusOrigin);\n            const subMove = subOriginIdx + offset;\n            if (subMove < 0 || subMove >= $subTabbable.length) {\n                // This element was on the edge of the list, so we'll pop focus out.\n                // We'll assume we can pop the focus to a controlled element.\n                const triggerEl = getTrigger($controlledElementWithFocus.get(0));\n                newFocusIdx = $tabbableElements.index(triggerEl);\n            } else {\n                // Focus will happen normally. Let it happen.\n                return;\n            }\n        }\n    }\n\n    if (newFocusIdx > -1) {\n        // wrap around the focus trap.\n        newFocusIdx = (newFocusIdx + offset) % $tabbableElements.length;\n    } else {\n        // we will focus the first element in the trap.\n        newFocusIdx = 0;\n    }\n\n    $tabbableElements.eq(newFocusIdx).trigger('focus');\n    event.preventDefault();\n}\n\n// AUI-4403 - Previous maintainers pretended multiple FocusManager instances made sense.\n// However, the class is implemented in a way that would never play well with others,\n// so here I'm locking it down as a singleton.\nlet instance;\nfunction getFocusManager() {\n    if (!instance) {\n        instance = new FocusManager();\n    }\n    return instance;\n}\ngetFocusManager.global = getFocusManager();\n\nglobalize('FocusManager', getFocusManager);\n\nexport default getFocusManager;\n","import $ from './jquery';\nimport { dim, undim } from './blanket';\nimport FocusManager from './focus-manager';\nimport {getTrigger,hasTrigger} from './trigger';\nimport globalize from './internal/globalize';\nimport keyCode from './key-code';\nimport widget from './internal/widget';\nimport CustomEvent from './polyfills/custom-event';\n\nexport const EVENT_PREFIX = '_aui-internal-layer-';\nconst GLOBAL_EVENT_PREFIX = '_aui-internal-layer-global-';\nconst LAYER_EVENT_PREFIX = 'aui-layer-';\nconst AUI_EVENT_PREFIX = 'aui-';\nvar $doc = $(document);\n\n// AUI-3708 - Abstracted to reflect code implemented upstream.\nfunction isTransitioning (el, prop) {\n    var transition = window.getComputedStyle(el).transitionProperty;\n    return transition ? transition.indexOf(prop) > -1 : false;\n}\n\nfunction onTransitionEnd (el, prop, func, once) {\n    function handler (e) {\n        if (prop !== e.propertyName) {\n            return;\n        }\n\n        func.call(el);\n\n        if (once) {\n            el.removeEventListener('transitionend', handler);\n        }\n    }\n\n    if (isTransitioning(el, prop)) {\n        el.addEventListener('transitionend', handler);\n    } else {\n        func.call(el);\n    }\n}\n\nfunction oneTransitionEnd (el, prop, func) {\n    onTransitionEnd(el, prop, func, true);\n}\n// end AUI-3708\n\nfunction ariaHide ($el) {\n    $el.attr('aria-hidden', 'true');\n}\n\nfunction ariaShow ($el) {\n    $el.attr('aria-hidden', 'false');\n}\n\n/**\n* @return {bool} Returns false if at least one of the event handlers called .preventDefault(). Returns true otherwise.\n*/\nfunction triggerEvent ($el, deprecatedName, newNativeName) {\n    var e1 = $.Event(EVENT_PREFIX + deprecatedName);\n    var e2 = $.Event(GLOBAL_EVENT_PREFIX + deprecatedName);\n    // TODO: Remove this 'aui-layer-' prefixed event once it is no longer used by inline dialog and dialog2.\n    var nativeEvent = new CustomEvent(LAYER_EVENT_PREFIX + newNativeName, {\n        bubbles: true,\n        cancelable: true\n    });\n    var nativeEvent2 = new CustomEvent(AUI_EVENT_PREFIX + newNativeName, {\n        bubbles: true,\n        cancelable: true\n    });\n\n    $el.trigger(e1);\n    $el.trigger(e2, [$el]);\n    $el[0].dispatchEvent(nativeEvent);\n    $el[0].dispatchEvent(nativeEvent2);\n\n    return !e1.isDefaultPrevented() &&\n        !e2.isDefaultPrevented() &&\n        !nativeEvent.defaultPrevented &&\n        !nativeEvent2.defaultPrevented;\n}\n\nfunction Layer (selector) {\n    this.$el = $(selector || '<div class=\"aui-layer\" aria-hidden=\"true\"></div>');\n    this.$el.addClass('aui-layer');\n}\n\nLayer.prototype = {\n    /**\n     * Returns the layer below the current layer if it exists.\n     *\n     * @returns {jQuery | undefined}\n     */\n    below: function () {\n        return LayerManager.global.item(LayerManager.global.indexOf(this.$el) - 1);\n    },\n\n    /**\n     * Returns the layer above the current layer if it exists.\n     *\n     * @returns {jQuery | undefined}\n     */\n    above: function () {\n        return LayerManager.global.item(LayerManager.global.indexOf(this.$el) + 1);\n    },\n\n    /**\n     * Sets the width and height of the layer.\n     *\n     * @param {Integer} width The width to set.\n     * @param {Integer} height The height to set.\n     *\n     * @returns {Layer}\n     */\n    changeSize: function (width, height) {\n        this.$el.css('width', width);\n        this.$el.css('height', height === 'content' ? '' : height);\n        return this;\n    },\n\n    /**\n     * Binds a layer event.\n     *\n     * @param {String} event The event name to listen to.\n     * @param {Function} fn The event handler.\n     *\n     * @returns {Layer}\n     */\n    on: function (event, fn) {\n        this.$el.on(EVENT_PREFIX + event, fn);\n        return this;\n    },\n\n\n    /**\n     * Unbinds a layer event.\n     *\n     * @param {String} event The event name to unbind=.\n     * @param {Function} fn Optional. The event handler.\n     *\n     * @returns {Layer}\n     */\n    off: function (event, fn) {\n        this.$el.off(EVENT_PREFIX + event, fn);\n        return this;\n    },\n\n    /**\n     * Shows the layer.\n     *\n     * @returns {Layer}\n     */\n    show: function () {\n        if (this.isVisible()) {\n            ariaShow(this.$el);\n            return this;\n        }\n\n        if (!triggerEvent(this.$el, 'beforeShow', 'show')) {\n            return this;\n        }\n\n        // AUI-3708\n        // Ensures that the display property is removed if it's been added\n        // during hiding.\n        if (this.$el.css('display') === 'none') {\n            this.$el.css('display', '');\n        }\n\n        LayerManager.global.push(this.$el);\n\n        return this;\n    },\n\n    /**\n     * Hides the layer.\n     *\n     * @returns {Layer}\n     */\n    hide: function () {\n        if (!this.isVisible()) {\n            ariaHide(this.$el);\n            return this;\n        }\n\n        if (!triggerEvent(this.$el, 'beforeHide', 'hide')) {\n            return this;\n        }\n\n        // AUI-3708\n        const thisLayer = this;\n        oneTransitionEnd(this.$el.get(0), 'opacity', function () {\n            if (!thisLayer.isVisible()) {\n                this.style.display = 'none';\n            }\n        });\n\n        LayerManager.global.popUntil(this.$el);\n\n        return this;\n    },\n\n    /**\n     * Checks to see if the layer is visible.\n     *\n     * @returns {Boolean}\n     */\n    isVisible: function () {\n        return this.$el.attr('aria-hidden') === 'false';\n    },\n\n    /**\n     * Removes the layer and cleans up internal state.\n     *\n     * @returns {undefined}\n     */\n    remove: function () {\n        this.hide();\n        this.$el.remove();\n        this.$el = null;\n    },\n\n    /**\n     * Returns whether or not the layer is blanketed.\n     *\n     * @returns {Boolean}\n     */\n    isBlanketed: function () {\n        return this.$el.attr('data-aui-blanketed') === 'true';\n    },\n\n    /**\n     * Returns whether or not the layer is persistent.\n     *\n     * @returns {Boolean}\n     */\n    isPersistent: function () {\n        var modal = this.$el.attr('modal') || this.$el.attr('data-aui-modal');\n        var isPersistent = this.$el[0].hasAttribute('persistent');\n\n        return modal === 'true' || isPersistent;\n    },\n\n    _hideLayer: function (triggerBeforeEvents) {\n        if (this.isPersistent() || this.isBlanketed()) {\n            FocusManager.global.exit(this.$el);\n        }\n\n        if (triggerBeforeEvents) {\n            triggerEvent(this.$el, 'beforeHide', 'hide');\n        }\n\n        this.$el.attr('aria-hidden', 'true');\n        this.$el.css('z-index', this.$el.data('_aui-layer-cached-z-index') || '');\n        this.$el.data('_aui-layer-cached-z-index', '');\n        this.$el.trigger(EVENT_PREFIX + 'hide');\n        this.$el.trigger(GLOBAL_EVENT_PREFIX + 'hide', [this.$el]);\n    },\n\n    _showLayer: function (zIndex) {\n        if (!this.$el.parent().is('body')) {\n            this.$el.appendTo(document.body);\n        }\n\n        this.$el.data('_aui-layer-cached-z-index', this.$el.css('z-index'));\n        this.$el.css('z-index', zIndex);\n        this.$el.attr('aria-hidden', 'false');\n\n        if (this.isPersistent() || this.isBlanketed()) {\n            FocusManager.global.enter(this.$el);\n        }\n\n        this.$el.trigger(EVENT_PREFIX + 'show');\n        this.$el.trigger(GLOBAL_EVENT_PREFIX + 'show', [this.$el]);\n    }\n};\n\nvar createLayer = widget('layer', Layer);\n\ncreateLayer.on = function (eventName, selector, fn) {\n    $doc.on(GLOBAL_EVENT_PREFIX + eventName, selector, fn);\n    return this;\n};\n\ncreateLayer.off = function (eventName, selector, fn) {\n    $doc.off(GLOBAL_EVENT_PREFIX + eventName, selector, fn);\n    return this;\n};\n\n\n\n// Layer Manager\n// -------------\n\n/**\n * Manages layers.\n *\n * There is a single global layer manager.\n * Additional instances can be created however this should generally only be used in tests.\n *\n * Layers are added by the push($el) method. Layers are removed by the\n * popUntil($el) method.\n *\n * popUntil's contract is that it pops all layers above & including the given\n * layer. This is used to support popping multiple layers.\n * Say we were showing a dropdown inside an inline dialog inside a dialog - we\n * have a stack of dialog layer, inline dialog layer, then dropdown layer. Calling\n * popUntil(dialog.$el) would hide all layers above & including the dialog.\n */\n\nfunction topIndexWhere (layerArr, fn) {\n    var i = layerArr.length;\n\n    while (i--) {\n        if (fn(layerArr[i])) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nfunction layerIndex (layerArr, $el) {\n    return topIndexWhere(layerArr, function ($layer) {\n        return $layer[0] === $el[0];\n    });\n}\n\nfunction topBlanketedIndex (layerArr) {\n    return topIndexWhere(layerArr, function ($layer) {\n        return createLayer($layer).isBlanketed();\n    });\n}\n\nfunction nextZIndex (layerArr) {\n    var _nextZIndex;\n\n    if (layerArr.length) {\n        var $topEl = layerArr[layerArr.length - 1];\n        var zIndex = parseInt($topEl.css('z-index'), 10);\n        _nextZIndex = (isNaN(zIndex) ? 0 : zIndex) + 100;\n    } else {\n        _nextZIndex = 0;\n    }\n\n    return Math.max(3000, _nextZIndex);\n}\n\nfunction updateBlanket (stack, oldBlanketIndex) {\n    var newTopBlanketedIndex = topBlanketedIndex(stack);\n\n    if (oldBlanketIndex !== newTopBlanketedIndex) {\n        if (newTopBlanketedIndex > -1) {\n            dim(false, stack[newTopBlanketedIndex].css('z-index') - 20);\n        } else {\n            undim();\n        }\n    }\n}\n\nfunction popLayers (stack, stopIndex, forceClosePersistent) {\n    if (stopIndex < 0) {\n        return;\n    }\n\n    for (var a = stack.length - 1; a >= stopIndex; a--) {\n        var $layer = stack[a];\n        var layer = createLayer($layer);\n\n        if (forceClosePersistent || !layer.isPersistent()) {\n            layer._hideLayer(true);\n            stack.splice(a, 1);\n        }\n    }\n}\n\nfunction getParentLayer (layer) {\n    var trigger = getTrigger(layer);\n\n    if (trigger) {\n        return $(trigger).closest('.aui-layer').get(0);\n    }\n}\n\nfunction LayerManager () {\n    this._stack = [];\n}\n\nLayerManager.prototype = {\n    /**\n    * Pushes a layer onto the stack. The same element cannot be opened as a layer multiple times - if the given\n    * element is already an open layer, this method throws an exception.\n    *\n    * @param {HTMLElement | String | jQuery} element  The element to push onto the stack.\n    *\n    * @returns {LayerManager}\n    */\n    push: function (element) {\n        var $el = (element instanceof $) ? element : $(element);\n        if (layerIndex(this._stack, $el) >= 0) {\n            throw new Error('The given element is already an active layer.');\n        }\n\n        this.popLayersBeside($el);\n\n        var layer = createLayer($el);\n        var zIndex = nextZIndex(this._stack);\n\n        layer._showLayer(zIndex);\n\n        if (layer.isBlanketed()) {\n            dim(false, zIndex - 20);\n        }\n\n        this._stack.push($el);\n\n        return this;\n    },\n\n    popLayersBeside: function (element) {\n        const layer = $(element).get(0);\n        if (!hasTrigger(layer)) {\n            // We can't find this layer's trigger, we will pop all non-persistent until a blanket or the document\n            var blanketedIndex = topBlanketedIndex(this._stack);\n            popLayers(this._stack, ++blanketedIndex, false);\n            return;\n        }\n\n        const parentLayer = getParentLayer(layer);\n        if (parentLayer) {\n            let parentIndex = this.indexOf(parentLayer);\n            popLayers(this._stack, ++parentIndex, false);\n        } else {\n            popLayers(this._stack, 0, false);\n        }\n    },\n\n    /**\n    * Returns the index of the specified layer in the layer stack.\n    *\n    * @param {HTMLElement | String | jQuery} element  The element to find in the stack.\n    *\n    * @returns {Number} the (zero-based) index of the element, or -1 if not in the stack.\n    */\n    indexOf: function (element) {\n        return layerIndex(this._stack, $(element));\n    },\n\n    /**\n    * Returns the item at the particular index or false.\n    *\n    * @param {Number} index The index of the element to get.\n    *\n    * @returns {jQuery | Boolean}\n    */\n    item: function (index) {\n        return this._stack[index];\n    },\n\n    /**\n    * Hides all layers in the stack.\n    *\n    * @returns {LayerManager}\n    */\n    hideAll: function () {\n        this._stack.slice().reverse().forEach(function (element) {\n            let layer = createLayer(element);\n            if (layer.isBlanketed() || layer.isPersistent()) {\n                return;\n            }\n            layer.hide();\n        });\n\n        return this;\n    },\n\n    /**\n    * Gets the previous layer below the given layer, which is non modal and non persistent. If it finds a blanketed layer on the way\n    * it returns it regardless if it is modal or not\n    *\n    * @param {HTMLElement | String | jQuery} element layer to start the search from.\n    *\n    * @returns {jQuery | null} the next matching layer or null if none found.\n    */\n    getNextLowerNonPersistentOrBlanketedLayer: function (element) {\n        var $el = (element instanceof $) ? element : $(element);\n        var index = layerIndex(this._stack, $el);\n\n        if (index < 0) {\n            return null;\n        }\n\n        var $nextEl;\n        index--;\n        while (index >= 0) {\n            $nextEl = this._stack[index];\n            var layer = createLayer($nextEl);\n\n            if (!layer.isPersistent() || layer.isBlanketed()) {\n                return $nextEl;\n            }\n            index--;\n        }\n\n        return null;\n    },\n\n    /**\n    * Gets the next layer which is neither modal or blanketed, from the given layer.\n    *\n    * @param {HTMLElement | String | jQuery} element layer to start the search from.\n    *\n    * @returns {jQuery | null} the next non modal non blanketed layer or null if none found.\n    */\n    getNextHigherNonPeristentAndNonBlanketedLayer: function (element) {\n        var $el = (element instanceof $) ? element : $(element);\n        var index = layerIndex(this._stack, $el);\n\n        if (index < 0) {\n            return null;\n        }\n\n        var $nextEl;\n        index++;\n        while (index < this._stack.length) {\n            $nextEl = this._stack[index];\n            var layer = createLayer($nextEl);\n\n            if (!(layer.isPersistent() || layer.isBlanketed())) {\n                return $nextEl;\n            }\n            index++;\n        }\n\n        return null;\n    },\n\n    /**\n    * Removes all non-modal layers above & including the given element. If the given element is not an active layer, this method\n    * is a no-op. The given element will be removed regardless of whether or not it is modal.\n    *\n    * @param {HTMLElement | String | jQuery} element layer to pop.\n    *\n    * @returns {jQuery} The last layer that was popped, or null if no layer matching the given $el was found.\n    */\n    popUntil: function (element) {\n        var $el = (element instanceof $) ? element : $(element);\n        var index = layerIndex(this._stack, $el);\n\n        if (index === -1) {\n            return null;\n        }\n\n        var oldTopBlanketedIndex = topBlanketedIndex(this._stack);\n\n        // Removes all layers above the current one.\n        popLayers(this._stack, index + 1, createLayer($el).isBlanketed());\n\n        // Removes the current layer.\n        createLayer($el)._hideLayer();\n        this._stack.splice(index, 1);\n\n        updateBlanket(this._stack, oldTopBlanketedIndex);\n\n        return $el;\n    },\n\n    /**\n    * Gets the top layer, if it exists.\n    *\n    * @returns The layer on top of the stack, if it exists, otherwise null.\n    */\n    getTopLayer: function () {\n        if (!this._stack.length) {\n            return null;\n        }\n\n        var $topLayer = this._stack[this._stack.length - 1];\n\n        return $topLayer;\n    },\n\n    /**\n    * Pops the top layer, if it exists and it is non modal and non persistent.\n    *\n    * @returns The layer that was popped, if it was popped.\n    */\n    popTopIfNonPersistent: function () {\n        var $topLayer = this.getTopLayer();\n        var layer = createLayer($topLayer);\n\n        if (!$topLayer || layer.isPersistent()) {\n            return null;\n        }\n\n        return this.popUntil($topLayer);\n    },\n\n    /**\n    * Pops all layers above and including the top blanketed layer. If layers exist but none are blanketed, this method\n    * does nothing.\n    *\n    * @returns The blanketed layer that was popped, if it exists, otherwise null.\n    */\n    popUntilTopBlanketed: function () {\n        var i = topBlanketedIndex(this._stack);\n\n        if (i < 0) {\n            return null;\n        }\n\n        var $topBlanketedLayer = this._stack[i];\n        var layer = createLayer($topBlanketedLayer);\n\n        if (layer.isPersistent()) {\n            // We can't pop the blanketed layer, only the things ontop\n            var $next = this.getNextHigherNonPeristentAndNonBlanketedLayer($topBlanketedLayer);\n            if ($next) {\n                var stopIndex = layerIndex(this._stack, $next);\n                popLayers(this._stack, stopIndex, true);\n                return $next;\n            }\n            return null;\n        }\n\n        popLayers(this._stack, i, true);\n        updateBlanket(this._stack, i);\n        return $topBlanketedLayer;\n    },\n\n    /**\n    * Pops all layers above and including the top persistent layer. If layers exist but none are persistent, this method\n    * does nothing.\n    */\n    popUntilTopPersistent: function () {\n        var $toPop = LayerManager.global.getTopLayer();\n        if (!$toPop) {\n            return;\n        }\n\n        var stopIndex;\n        var oldTopBlanketedIndex = topBlanketedIndex(this._stack);\n\n        var toPop = createLayer($toPop);\n        if (toPop.isPersistent()) {\n            if (toPop.isBlanketed()) {\n                return;\n            } else {\n                // Get the closest non modal layer below, stop at the first blanketed layer though, we don't want to pop below that\n                $toPop = LayerManager.global.getNextLowerNonPersistentOrBlanketedLayer($toPop);\n                toPop = createLayer($toPop);\n\n                if ($toPop && !toPop.isPersistent()) {\n                    stopIndex = layerIndex(this._stack, $toPop);\n                    popLayers(this._stack, stopIndex, true);\n                    updateBlanket(this._stack, oldTopBlanketedIndex);\n                } else {\n                    // Here we have a blanketed persistent layer\n                    return;\n                }\n            }\n        } else {\n            stopIndex = layerIndex(this._stack, $toPop);\n            popLayers(this._stack, stopIndex, true);\n            updateBlanket(this._stack, oldTopBlanketedIndex);\n        }\n    }\n};\n\n// LayerManager.global\n// -------------------\n\nfunction initCloseLayerOnEscPress() {\n    $doc.on('keydown', function (e) {\n        if (e.keyCode === keyCode.ESCAPE) {\n            LayerManager.global.popUntilTopPersistent();\n            e.preventDefault();\n        }\n    });\n}\n\nfunction initCloseLayerOnBlanketClick() {\n    $doc.on('click', '.aui-blanket', function (e) {\n        if (LayerManager.global.popUntilTopBlanketed()) {\n            e.preventDefault();\n        }\n    });\n}\n\nfunction hasLayer($trigger) {\n    if (!$trigger.length) {\n        return false;\n    }\n\n    var layer = document.getElementById($trigger.attr('aria-controls'));\n    return LayerManager.global.indexOf(layer) > -1;\n}\n\n// If it's a click on a trigger, do nothing.\n// If it's a click on a layer, close all layers above.\n// Otherwise, close all layers.\nfunction initCloseLayerOnOuterClick () {\n    $doc.on('click', function (e) {\n        var $target = $(e.target);\n        if ($target.closest('.aui-blanket').length) {\n            return;\n        }\n\n        var $trigger = $target.closest('[aria-controls]');\n        var $layer = $target.closest('.aui-layer');\n        if (!$layer.length && !hasLayer($trigger)) {\n            const customEvent = $.Event('aui-close-layers-on-outer-click');\n            $doc.trigger(customEvent);\n            if (customEvent.isDefaultPrevented()) {\n                e.preventDefault();\n                return;\n            }\n            LayerManager.global.hideAll();\n            return;\n        }\n\n        // Triggers take precedence over layers\n        if (hasLayer($trigger)) {\n            return;\n        }\n\n        if ($layer.length) {\n            // We dont want to explicitly call close on a modal dialog if it happens to be next.\n            // All blanketed layers should be below us, as otherwise the blanket should have caught the click.\n            // We make sure we dont close a blanketed one explicitly as a hack, this is to fix the problem arising\n            // from dialog2 triggers inside dialog2's having no aria controls, where the dialog2 that was just\n            // opened would be closed instantly\n            var $next = LayerManager.global.getNextHigherNonPeristentAndNonBlanketedLayer($layer);\n\n            if ($next) {\n                createLayer($next).hide();\n            }\n        }\n    });\n}\n\ninitCloseLayerOnEscPress();\ninitCloseLayerOnBlanketClick();\ninitCloseLayerOnOuterClick();\n\nLayerManager.global = new LayerManager();\ncreateLayer.Manager = LayerManager;\n\nglobalize('layer', createLayer);\n\nexport default createLayer;\n"],"sourceRoot":""}