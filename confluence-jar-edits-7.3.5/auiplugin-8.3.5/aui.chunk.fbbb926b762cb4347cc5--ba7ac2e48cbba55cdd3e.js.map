{"version":3,"sources":["webpack:///../src/js/aui/format.js"],"names":["formatString","message","apos","simpleFormat","numberFormat","choiceFormat","choicePart","getParamValue","format","args","match","res","length","value","options","split","prevOptionValue","i","parts","argValue","parseInt","formatArgs","concat","Array","prototype","slice","call","apply","_performTokenRegex","tick","openIndex","openCount","c","charAt","push","substring","arguments","replace","__webpack_require__","default"],"mappings":"iHAmBA,SAASA,EAAcC,GACnB,IAAIC,EAAO,UACPC,EAAe,QACfC,EAAe,iBACfC,EAAe,qBACfC,EAAa,mBAIbC,EAAgB,SAAUC,EAAQC,GAElC,IAEIC,EAFAC,EAAM,GAGV,GAAID,EAAQF,EAAOE,MAAMP,GACrBQ,EAAMF,EAAKG,SAAWJ,EAASC,EAAKD,GAAU,QAI7C,GAAIE,EAAQF,EAAOE,MAAMN,GAE1BO,EAAMF,EAAKG,SAAWF,EAAM,GAAKD,EAAKC,EAAM,IAAM,QAIjD,GAAIA,EAAQF,EAAOE,MAAML,GAAe,CAOzC,IAAIQ,EAASJ,EAAKG,SAAWF,EAAM,GAAKD,EAAKC,EAAM,IAAM,KACzD,GAAc,OAAVG,EAAgB,CAShB,IAHA,IAAIC,EAAUJ,EAAM,GAAGK,MAAM,KAEzBC,EAAkB,KACbC,EAAI,EAAGA,EAAIH,EAAQF,OAAQK,IAAK,CAMrC,IAAIC,EAAQJ,EAAQG,GAAGP,MAAMJ,GAGzBa,EAAWC,SAASF,EAAM,GAAI,IAClC,GAAIL,EAAQM,EAAU,CAClB,GAAIH,EAAiB,CACjBL,EAAMK,EACN,MAEAL,EAAMO,EAAM,GACZ,MAIR,GAAIL,GAASM,GAAwB,KAAZD,EAAM,GAAW,CACtCP,EAAMO,EAAM,GACZ,MAMAD,GAAKH,EAAQF,OAAS,IACtBD,EAAMO,EAAM,IAIhBF,EAAkBE,EAAM,GAI5B,IAAIG,GAAcV,GAAKW,OAAOC,MAAMC,UAAUC,MAAMC,KAAKjB,EAAM,IAC/DE,EAAMX,EAAa2B,MAAM,KAAMN,IAGvC,OAAOV,GAOPiB,EAAqB,SAAU3B,GAI/B,IAHA,IAAI4B,GAAO,EACPC,GAAa,EACbC,EAAY,EACPd,EAAI,EAAGA,EAAIhB,EAAQW,OAAQK,IAAK,CAErC,IAAIe,EAAI/B,EAAQgC,OAAOhB,GAMvB,GALS,KAALe,IAEAH,GAAQA,IAGRA,EAIJ,GAAU,MAANG,EACkB,IAAdD,IACAD,EAAYb,GAEhBc,SACG,GAAU,MAANC,GACHD,EAAY,GAEM,MADlBA,EACqB,CAEjB,IAAIrB,KAIJ,OAHAA,EAAMwB,KAAKjC,EAAQkC,UAAU,EAAGlB,EAAI,IACpCP,EAAMwB,KAAKjC,EAAQkC,UAAU,EAAGL,IAChCpB,EAAMwB,KAAKjC,EAAQkC,UAAUL,EAAY,EAAGb,IACrCP,GAKvB,OAAO,MA+BX,OA5BoB,SAAUT,GAC1B,IAAIQ,EAAO2B,UACPzB,EAAM,GAEV,IAAKV,EACD,OAAOU,EAKX,IAFA,IAAID,EAAQkB,EAAmB3B,GAExBS,GAEHT,EAAUA,EAAQkC,UAAUzB,EAAM,GAAGE,QAGrCD,GAAOD,EAAM,GAAG2B,QAAQnC,EAAM,IAG9BS,GAAOJ,EAAcG,EAAM,GAAID,GAG/BC,EAAQkB,EAAmB3B,GAI/B,OADAU,GAAOV,EAAQoC,QAAQnC,EAAM,KAIZyB,MAAM,KAAMS,6DAGrC,oDAlLAE,EAAA,SAkLAC,SAAU,SAAUvC,aAELA","file":"aui.chunk.fbbb926b762cb4347cc5--ba7ac2e48cbba55cdd3e.js","sourcesContent":["import globalize from './internal/globalize';\n\n/* eslint brace-style: off, complexity:off, eqeqeq:off, max-depth:off, no-cond-assign:off, no-unused-vars:off */\n\n/**\n * Replaces tokens in a string with arguments, similar to Java's MessageFormat.\n * Tokens are in the form {0}, {1}, {2}, etc.\n *\n * This version also provides support for simple choice formats (excluding floating point numbers) of the form\n * {0,choice,0#0 issues|1#1 issue|1<{0,number} issues}\n *\n * Number format is currently not implemented, tokens of the form {0,number} will simply be printed as {0}\n *\n * @method format\n * @param message the message to replace tokens in\n * @param arg (optional) replacement value for token {0}, with subsequent arguments being {1}, etc.\n * @return {String} the message with the tokens replaced\n * @usage formatString(\"This is a {0} test\", \"simple\");\n */\nfunction formatString (message) {\n    var apos = /'(?!')/g; // founds \"'\", but not \"''\" // TODO: does not work for floating point numbers!\n    var simpleFormat = /^\\d+$/;\n    var numberFormat = /^(\\d+),number$/; // TODO: incomplete, as doesn't support floating point numbers\n    var choiceFormat = /^(\\d+),choice,(.+)/;\n    var choicePart = /^(\\d+)([#<])(.+)/;\n    // we are caching RegExps, so will not spend time on recreating them on each call\n\n    // formats a value, currently choice and simple replacement are implemented, proper\n    var getParamValue = function (format, args) {\n        // simple substitute\n        var res = '';\n\n        var match;\n        if (match = format.match(simpleFormat)) { // TODO: heavy guns for checking whether format is a simple number...\n            res = args.length > ++format ? args[format] : ''; // use the argument as is, or use '' if not found\n        }\n\n        // number format\n        else if (match = format.match(numberFormat)) {\n            // TODO: doesn't actually format the number...\n            res = args.length > ++match[1] ? args[match[1]] : '';\n        }\n\n        // choice format\n        else if (match = format.match(choiceFormat)) {\n            // format: \"0,choice,0#0 issues|1#1 issue|1<{0,number} issues\"\n            // match[0]: \"0,choice,0#0 issues|1#1 issue|1<{0,number} issues\"\n            // match[1]: \"0\"\n            // match[2]: \"0#0 issues|1#1 issue|1<{0,number} issues\"\n\n            // get the argument value we base the choice on\n            var value = (args.length > ++match[1] ? args[match[1]] : null);\n            if (value !== null) {\n                // go through all options, checking against the number, according to following formula,\n                // if X < the first entry then the first entry is returned, if X > last entry, the last entry is returned\n                //\n                //    X matches j if and only if limit[j] <= X < limit[j+1]\n                //\n                var options = match[2].split('|');\n\n                var prevOptionValue = null; // holds last passed option\n                for (var i = 0; i < options.length; i++) {\n                    // option: \"0#0 issues\"\n                    // part[0]: \"0#0 issues\"\n                    // part[1]: \"0\"\n                    // part[2]: \"#\"\n                    // part[3]\" \"0 issues\";\n                    var parts = options[i].match(choicePart);\n\n                    // if value is smaller, we take the previous value, or the current if no previous exists\n                    var argValue = parseInt(parts[1], 10);\n                    if (value < argValue) {\n                        if (prevOptionValue) {\n                            res = prevOptionValue;\n                            break;\n                        } else {\n                            res = parts[3];\n                            break;\n                        }\n                    }\n                    // if value is equal the condition, and the match is equality match we accept it\n                    if (value == argValue && parts[2] == '#') {\n                        res = parts[3];\n                        break;\n                    } else {\n                        // value is greater the condition, fall through to next iteration\n                    }\n\n                    // check whether we are the last option, in which case accept it even if the option does not match\n                    if (i == options.length - 1) {\n                        res = parts[3];\n                    }\n\n                    // retain current option\n                    prevOptionValue = parts[3];\n                }\n\n                // run result through format, as the parts might contain substitutes themselves\n                var formatArgs = [res].concat(Array.prototype.slice.call(args, 1));\n                res = formatString.apply(null, formatArgs);\n            }\n        }\n        return res;\n    };\n\n    // drop in replacement for the token regex\n    // splits the message to return the next accurance of a i18n placeholder.\n    // Does not use regexps as we need to support nested placeholders\n    // text between single ticks ' are ignored\n    var _performTokenRegex = function (message) {\n        var tick = false;\n        var openIndex = -1;\n        var openCount = 0;\n        for (var i = 0; i < message.length; i++) {\n            // handle ticks\n            var c = message.charAt(i);\n            if (c == \"'\") {\n                // toggle\n                tick = !tick;\n            }\n            // skip if we are between ticks\n            if (tick) {\n                continue;\n            }\n            // check open brackets\n            if (c === '{') {\n                if (openCount === 0) {\n                    openIndex = i;\n                }\n                openCount++;\n            } else if (c === '}') {\n                if (openCount > 0) {\n                    openCount--;\n                    if (openCount === 0) {\n                        // we found a bracket match - generate the result array (\n                        var match = [];\n                        match.push(message.substring(0, i + 1)); // from begin to match\n                        match.push(message.substring(0, openIndex)); // everything until match start\n                        match.push(message.substring(openIndex + 1, i)); // matched content\n                        return match;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    var _formatString = function (message) {\n        var args = arguments;\n        var res = '';\n\n        if (!message) {\n            return res;\n        }\n\n        var match = _performTokenRegex(message);\n\n        while (match) {\n            // reduce message to string after match\n            message = message.substring(match[0].length);\n\n            // add value before match to result\n            res += match[1].replace(apos, '');\n\n            // add formatted parameter\n            res += getParamValue(match[2], args);\n\n            // check for next match\n            match = _performTokenRegex(message); //message.match(token);\n        }\n        // add remaining message to result\n        res += message.replace(apos, '');\n        return res;\n    };\n\n    return _formatString.apply(null, arguments);\n}\n\nglobalize('format', formatString);\n\nexport default formatString;\n"],"sourceRoot":""}